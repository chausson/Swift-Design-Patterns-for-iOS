
比如在面向对象的世界中，我们把一个iOS小组连接成一个链条，每个人都有自己的专长，联合起来就能成为一个强大的实体。比如我现在需要适配ipad，可能我不懂怎么去做，于是我问旁边的程序员，如果他也不知道他会继续问他旁边的或者朋友，直到问题解决或者美人解决了。当然有的人愿意回答问题，有的人可能知道也不想回答，于是他把问题交给另一个解决。
还有就是我们可以想象一个工厂的流水线，需要经过多道不同的工序来完成，每道工序都有每个专人去负责。如一款笔记本电脑，我们需要经过，假设我们需要经过零件组装，硬件测试，系统安装，打包发货等四个工序才能发货给买家。每个工序都有不同的人员去负责，直到最后一个工序完成。零件组装的人员拼装完了电脑，告诉性能测试的人员:“我装完了，把电脑给你，你来进行硬件测试”，硬件测试的人员结束时会对系统安装人说:"OK，我现在测完了，把电脑给你"。这种“责任”的链条，允许进一步的升级或者拓展，而不必修改已经有单元的功能。只要把新的单元添加到链中，链就会有更多的功能。这就像我们在生产链中增加一个流程，在系统安装以后增加一个软件测试流程。

这种概念对于面向对象的软件设计同样适用。比如，让一组对象处理特定的请求，而对这个组添加或删除处理程序都不影响组的完整性。

# 何为责任链模式
  责任链模式的主要思想是，对象引用了同一类型的另一个对象，形成一条链。链中的每个对象实现了同样的方法，处理对链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个响应者，iOS中事件传递就是按照响应链模式来设计的。
# 何时使用责任链模式
* 有多个对象可以处理请求，而处理程序只有在运行时才确定。
* 向一组对象发出请求,而不想显式指定处理请求的特定处理程序。	

下面我们来看一下伪代码,利用Swift,以售卖画作为一个业务场景,一幅画的想要拍卖,会经过个人，如果个人不能拍卖交给基金，基金部行的话交给银行。

import UIKit
protocol Sale {
     func sale(paint:CanvasView) -> Bool
}
//MARK: - 拍卖抽象类
class ApplyHandler: Sale {
    var nextHandler:ApplyHandler?
    func sale(paint:CanvasView) -> Bool {

        if let handler = nextHandler{
          return handler.sale(paint: paint)
        }else{
          return false
        }
        
    }
}

class PersonApplyHandler: ApplyHandler {
    override func sale(paint: CanvasView) -> Bool {
        if  paint.price > 0  && paint.price < 100{
            return true
        }else{
            return super.sale(paint: paint)
        }
    }
}
class FundApplyHandler: ApplyHandler {
    override func sale(paint: CanvasView) -> Bool {
        if  paint.price > 1000  && paint.price < 10000{
            return true
        }else{
            return super.sale(paint: paint)
        }
    }
}
class BankApplyHandler: ApplyHandler {
    override func sale(paint: CanvasView) -> Bool {
        if  paint.price > 10000  && paint.price < 100000{
            return true
        }else{
            return super.sale(paint: paint)
        }
    }
}

func main() {
    let canvas:OilCanvasView =  OilCanvasView()
    ApplyHandler().sale(canvas)
}
